<!DOCTYPE html>
<html lang="en-us">

  <head>
  <!-- for MathJax support -->
  
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script>
  


  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      The .flac format &#58; linear predictive coding and rice codes &middot; UfoRoblog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0d">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
    
      
    

    <!--
    <a class="sidebar-nav-item" href="/archive/v.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v</span>
    -->
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">UfoRoblog</a>
            <small>A blog about stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">The .flac format &#58; linear predictive coding and rice codes</h1>
  <span class="post-date">01 Apr 2018</span>
  <h1 id="introduction">Introduction</h1>
<p><strong>FLAC</strong> stands for <strong>F</strong>ree <strong>L</strong>ossless <strong>A</strong>udio <strong>C</strong>odec. It’s the standard open source codec used nowadays for lossless audio compression. In this post I would like to take the .flac format as an example and focus on two core step of the process of lossless audio compression: linear predictive coding and entropy coding with Rice codes.</p>

<h3 id="tltr">TL;TR</h3>
<p>Most lossless audio compression codecs work very similarly: first the audio stream is split into blocks, and then each one is compressed. Compression is achieved identifying and modelling structure in the signal: any explicit structure and repeating pattern is redundant by definition and can be instead represented more efficiently using a mathematical model and its parameters to approximate it. Usually a very simple model is used, from constant values to model silence to the more flexible linear predictive coding (a linear autoregressive model). In order to recreate the signal exactly, the approximation residuals are also saved but using a coding scheme optimised for their distribution. Linear predictive coding leads to residual Laplace-distributed and hence usually the Rice coding scheme is used.</p>

<h1 id="linear-predictive-coding">Linear predictive coding</h1>
<p>Linear predictive coding is a modelling technique equivalent to an \(AR(p)\) auto regressive model: the signal \(X_t\) at time \(t\) is modelled as a linear combination of its previous \(p\) values.</p>

<p>More formally, let \({X_t}\) be a wide sense stationary (WSS) stochastic process with zero mean and with the \(AR(p)\) property, which is:</p>

<p>\[
\begin{equation}\label{eqn:wss_1}
E[X_t] = \mu = 0   \quad \forall t
\end{equation}
\]</p>

<p>\[
\begin{equation}\label{eqn:wss_2}
Cov[X_{t}, X_{t + \tau}] = Cov[X_{t+h}, X_{t +h + \tau}]  \quad \forall t \ \forall h <br />
\end{equation}
\]</p>

<p>From \ref{eqn:wss_1} and \ref{eqn:wss_2} it follows that the covariance function only depends on the lag \(\tau\) and can be expressed in terms of the autocorrelation function \(R(\tau)\):</p>

<p>\[\begin{equation}\label{eqn:autocorr}
Cov[X_{t}, X_{t + \tau}] = E[(X_t - \mu)(X_{t + \tau} - \mu)] = E[X_tX_{t+\tau}] = R(\tau)
\end{equation}\]
where \(R(\tau) = R(-\tau)\) is symmetric.</p>

<p>Assume that we wanted to approximate each value \(X_t\) as a linear combination of its previous \(p\) values:</p>

<p>\[ \hat{X_t} = \sum_{k = 1}^{p}\alpha_k X_{t-k} \]</p>

<p>now let \(\boldsymbol{\boldsymbol{\alpha}} =  \begin{bmatrix} \alpha_1 &amp; \cdots &amp; \alpha_p \end{bmatrix}^\top \), the approximation error \(\epsilon_t\) at time t is the random variable:</p>

<p>\[
\epsilon_t    =  X_t - \hat{X_t} 
            =  X_t - \mathbf{\boldsymbol{\alpha}}^\top \begin{bmatrix} X_{t-1} \\ \vdots \\ X_{t-p} \end{bmatrix} 
            =  X_t - \mathbf{\boldsymbol{\alpha}}^\top \mathbf{X_{t-1:t-p}}
\]</p>

<p>We can then chose \(\boldsymbol{\alpha}\) so that it minimises the expected squared estimation error.</p>

<blockquote>
  <p><strong>Lemma: Orthogonality principle.</strong><br />
The estimate \(\hat{X_t} \) minimises the expected squared error if and only if the estimation error \(\epsilon_t\) is orthogonal to the \(p\) random variables \(X_{t-1}, …, X_{t-p}\), ie if and only if:
\[
E[\epsilon_t X_{t-i}] = 0 \quad \forall 1 \leq i \leq p
\]</p>
</blockquote>

<p>We can use the orthogonality principle to derive the Yule-Walker equations:
\[
\begin{equation}\label{eqn:yw}
\begin{split}
\mathbf{0} = &amp; E[\epsilon_t \mathbf{X_{t-1:t-p}}] \\
           = &amp; E[(X_t - \mathbf{X_{t-1:t-p}}^\top\alpha)\mathbf{X_{t-1:t-p}}] \\
           = &amp; E[X_t \mathbf{X_{t-1:t-p}} - \mathbf{X_{t-1:t-p}}^\top\boldsymbol{\alpha}\mathbf{X_{t-1:t-p}}] \\
            = &amp; E[X_t \mathbf{X_{t-1:t-p}} - trace(\mathbf{X_{t-1:t-p}}^\top\boldsymbol{\alpha}\mathbf{X_{t-1:t-p}})] \\
            = &amp; E[X_t \mathbf{X_{t-1:t-p}} - trace(\mathbf{X_{t-1:t-p}}\mathbf{X_{t-1:t-p}}^\top\boldsymbol{\alpha})] \\
            = &amp; E[X_t \mathbf{X_{t-1:t-p}} - \mathbf{X_{t-1:t-p}}\mathbf{X_{t-1:t-p}}^\top\boldsymbol{\alpha}] \\
            = &amp; E[X_t \mathbf{X_{t-1:t-p}}] - E[ \mathbf{X_{t-1:t-p}}\mathbf{X_{t-1:t-p}}^\top]\boldsymbol{\alpha} \\
\end{split}
\end{equation}
\]</p>

<p>Using \ref{eqn:autocorr} we can rewrite \( E[ \mathbf{X_{t-1:t-p}}\mathbf{X_{t-1:t-p}}]^\top = \mathbf{R}\)  as:</p>

<p>\[
\mathbf{R} = 
\begin{bmatrix}
R(0) &amp; R(1) &amp; R(2) &amp; \cdots &amp; R(p-1) \\
R(1) &amp; R(0) &amp; R(1) &amp; \cdots &amp; R(p-2) \\
R(2) &amp; R(1) &amp; R(0) &amp; \cdots &amp; R(p-3) \\
\vdots  &amp; \vdots   &amp; \vdots &amp;  &amp; \vdots \\
R(p-1) &amp; R(p-2) &amp; R(p-3) &amp; \cdots &amp; R(0) \\
\end{bmatrix}
\]</p>

<p>and by letting \(\mathbf{r} = \begin{bmatrix} R(1) &amp; \cdots &amp; R(p) \end{bmatrix}^\top\) we can rewrite \ref{eqn:yw} as:</p>

<p>\begin{equation}\label{eqn:yh2}
\mathbf{R}\boldsymbol{\alpha} = \mathbf{r} <br />
\end{equation}</p>

<p>which can be solved for \(\boldsymbol{\alpha}\) given estimates of \(\mathbf{R}\) and \(\mathbf{r}\)</p>

<p>Note that the matrix \(\mathbf{R}\) is a <em>toeplitz</em> matrix. A toeplitz matrix has the property that each descending diagonal from left to right is constant and there exist an algorithm, the Levinson–Durbin recursion, to solve the system in \(O(p^2)\) instead of simply inverting \(\mathbf{R}\), which would have a cost \(O(p^3)\). The overall computational cost is thus \(O(np + p^2)\) where the first term comes from the cost of computing the sample estimate of the auto correlation matrix.</p>

<h2 id="comparison-with-ordinary-least-squares">Comparison with ordinary least squares</h2>
<p>The previous model could have been expressed as an instance of a general linear regression model whose covariates are the \(p\) lagged values. The solution minimises for the expected mean squared error directly, without making assumptions about the underlying WSS property. This leads to a very similar but more expensive solution.</p>

<p>The normal equations for the general linear regression problem are:
\[
(\mathbf{X}^\top \mathbf{X})\mathbf{\boldsymbol{\alpha}} =  \mathbf{X}^\top \mathbf{y}
\]</p>

<p>where:
\[
\mathbf{y} = \begin{bmatrix}
    y_{p+1}\\
    \vdots \\
    y_n \\
    \vdots \\
    y_N
\end{bmatrix}
\]</p>

<p>\[
\mathbf{X} = \begin{bmatrix}
y_p  &amp; y_{p-1} &amp; \cdots &amp; y_0 \\
\vdots  &amp;\vdots   &amp;  &amp;\vdots   \\
y_n  &amp; y_{n-1} &amp; \cdots &amp; y_{n-p} \\
\vdots  &amp;\vdots   &amp;  &amp;\vdots   \\
y_N  &amp; y_{N-1} &amp; \cdots &amp; y_{N-p} \\ <br />
\end{bmatrix}
\]</p>

<p>\[
\mathbf{\boldsymbol{\alpha}} = \begin{bmatrix}
    \alpha_1\\
    \vdots \\
    \alpha_p \\
\end{bmatrix}
\]</p>

<p>It is easy to notice the similarities with equation \ref{eqn:yh2} : this solution is computing the sample estimates of \(\mathbf{R}\) and \( \mathbf{r}\), but using a different subset of samples for each estimate. Because of this the estimates have to be recomputed for each entry, and the toeplitz structure is lost, rsulting in higher estimation costs to build the matrices and higher matrix inversion costs to solve for \(\boldsymbol{\alpha}\). The computational complexity of this solution is \(O(n^2p + p^3)\), where the first term comes from the inner product of the matrix of covariates and the second term from its inversion. Usually \(n \gg p\) and thus this solution has complexity \(O(n^2p)\) which is much worst than the previous result of \(O(np)\) when using \ref{eqn:yh2}</p>

<p><em>Entropy coding and Rice codes</em>
Suppose one was to observe a realisation of the above mentioned stochastic process and used LPC (or some other model) to approximate it. In order to reconstruct the original signal without approximation error it is necessary to know what the exact realisation of the reconstruction error were and add them to the reconstruction. The problem of efficiently storing these residuals is an instance of <em>entropy encoding</em>.</p>

<p>Assume the observed data can be modelled as a discrete random variable (note that we redefine (X) from the previous section):
\[ X : \Omega \rightarrow \boldsymbol{\chi} \]
where \(P(x \in X) = P(x)\)</p>

<p>now, given an alphate of symbols \(\Sigma\), in the digital case \(\Sigma = {0, 1}\), a code is defined as
\[C : \boldsymbol{\chi} \rightarrow \Sigma^*\]
\(C(x)\) is the code associated with \(x\). Let its length be \(l(C(x))\), then the expected length of a code is:
\[l(C) = E_{x \sim P(x)}[l(C(x))] = \sum_{x \in \chi} P(x)l(C(x))\]</p>

<p>when designing or choosing a code the objective is to minimise \(l(C)\) for the distribution of input words \(p(x)\), so that the encoded input will require on average the least number of symbols. This is the problem referred to as <em>entropy coding</em></p>

<p>A good general code that works for any input distribution is the Huffman code [1], and is for example used in the popular compression tool <em>gzip</em>. When the distribution of the input is known a priori though it is possible to use a coding scheme tailored for that distribution.</p>

<p>For the case of alphabets following a geometric distribution the optimal prefix code (a prefix code is a code where no code-word is allowed to be the prefix of another code-word) is the Golomb code [3], making it highly suitable for situations in which the occurrence of small values in the input stream is significantly more likely than large values, as for the case of the reconstruction errors.</p>

<p>Golomb coding [2] was invented by Solomon W. Golomb in the 1960s. It takes the input \(s\) and divides it by the tunable parameter \(m\). First the quotient is encoded in <em>unary coding</em> and then the remainder is econded in \textit{truncated binary coding}. Rice coding is a special case of Golomb coding where (m = 2^k), which is faster to encode and decode thanks to the usage of powers of 2. It is very intuitive to understand how the coding scheme works just by looking at the example in the following table</p>

<p>#Entropy coding and Rice codes
Suppose one was to observe a realisation of the above mentioned stochastic process and used LPC (or some other model) to approximate it. In order to reconstruct the original signal without approximation error it is necessary to know what the exact realisation of the reconstruction error were and add them to the reconstruction. The problem of efficiently storing these residuals is an instance of <em>entropy encoding</em>.</p>

<p>Assume the observed data can be modelled as a discrete random variable (note that we redefine \(X\) from the previous section):
\[ X : \Omega \rightarrow \boldsymbol{\chi} \]
where \(P(x \in X) = P(x)\)</p>

<p>now, given an alphate of symbols \(\Sigma\), in the digital case \(\Sigma = {0, 1}\), a code is defined as
[\C : \boldsymbol{\chi} \rightarrow \Sigma^*\]
\(C(x)\) is the code associated with \(x\). Let its length be \(l(C(x))\), then the expected length of a code is:
\[l(C) = E_{x \sim P(x)}[l(C(x))] = \sum_{x \in \chi} P(x)l(C(x))\]</p>

<p>when designing or choosing a code the objective is to minimise \(l(C)\) for the distribution of input words \(p(x)\), so that the encoded input will require on average the least number of symbols. This is the problem referred to as <em>entropy coding</em></p>

<p>A good general code that works for any input distribution is the Huffman code [1], and is for example used in the popular compression tool <em>gzip</em>. When the distribution of the input is known a priori though it is possible to use a coding scheme tailored for that distribution.</p>

<p>For the case of alphabets following a geometric distribution the optimal prefix code (a prefix code is a code where no code-word is allowed to be the prefix of another code-word) is the Golomb code \cite{gallager1975optimal}, making it highly suitable for situations in which the occurrence of small values in the input stream is significantly more likely than large values, as for the case of the reconstruction errors.</p>

<p>Golomb coding \cite{golomb1966run} was invented by Solomon W. Golomb in the 1960s. It takes the input \(s\) and divides it by the tunable parameter \(m\). First the quotient is encoded in <em>unary coding</em> and then the remainder is econded in <em>truncated binary coding</em>. Rice coding is a special case of Golomb coding where \(m = 2^k\), which is faster to encode and decode thanks to the usage of powers of 2. It is very intuitive to understand how the coding scheme works just by looking at the follwowing table example</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Golomb</th>
      <th>m=1</th>
      <th>m=2</th>
      <th>m=3</th>
      <th>m=4</th>
      <th>m=5</th>
      <th>m=6</th>
      <th>m=7</th>
      <th>m=8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><strong>Rice</strong></td>
      <td><strong>k=0</strong></td>
      <td><strong>k=1</strong></td>
      <td> </td>
      <td><strong>k=2</strong></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td><strong>k=3</strong></td>
    </tr>
    <tr>
      <td style="text-align: right">s = 0</td>
      <td>0</td>
      <td>00</td>
      <td>00</td>
      <td>000</td>
      <td>000</td>
      <td>000</td>
      <td>000</td>
      <td>0000</td>
    </tr>
    <tr>
      <td style="text-align: right">1</td>
      <td>10</td>
      <td>01</td>
      <td>010</td>
      <td>001</td>
      <td>001</td>
      <td>001</td>
      <td>0010</td>
      <td>0001</td>
    </tr>
    <tr>
      <td style="text-align: right">2</td>
      <td>110</td>
      <td>100</td>
      <td>011</td>
      <td>010</td>
      <td>010</td>
      <td>0100</td>
      <td>0011</td>
      <td>0010</td>
    </tr>
    <tr>
      <td style="text-align: right">3</td>
      <td>1110</td>
      <td>101</td>
      <td>100</td>
      <td>011</td>
      <td>0110</td>
      <td>0101</td>
      <td>0100</td>
      <td>0011</td>
    </tr>
    <tr>
      <td style="text-align: right">4</td>
      <td>11110</td>
      <td>1100</td>
      <td>1010</td>
      <td>1000</td>
      <td>0111</td>
      <td>0110</td>
      <td>0101</td>
      <td>0100</td>
    </tr>
    <tr>
      <td style="text-align: right">5</td>
      <td>\(1^50\)</td>
      <td>1101</td>
      <td>1011</td>
      <td>1001</td>
      <td>1000</td>
      <td>0111</td>
      <td>0110</td>
      <td>0101</td>
    </tr>
    <tr>
      <td style="text-align: right">6</td>
      <td>\(1^60\)</td>
      <td>11100</td>
      <td>1100</td>
      <td>11010</td>
      <td>1001</td>
      <td>1000</td>
      <td>0111</td>
      <td>0110</td>
    </tr>
    <tr>
      <td style="text-align: right">7</td>
      <td>\(1^70\)</td>
      <td>11101</td>
      <td>11010</td>
      <td>1011</td>
      <td>1010</td>
      <td>1001</td>
      <td>1000</td>
      <td>0111</td>
    </tr>
    <tr>
      <td style="text-align: right">8</td>
      <td>\(1^80\)</td>
      <td>111100</td>
      <td>11100</td>
      <td>11000</td>
      <td>10110</td>
      <td>10100</td>
      <td>10010</td>
      <td>1000</td>
    </tr>
    <tr>
      <td style="text-align: right">…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<h1 id="the-flac-codec">The FLAC codec</h1>
<p>At this point it should be intuitive how modelling and entropy coding can be combined to form a lossless audio codec. FLAC is mainly based on <em>shorten</em> [4], with additional features for more convenient use in real case consumer scenarios.</p>

<p><img src="http://localhost:4000/assets/flac_stream.png" alt="The FLAC stream" /></p>

<p>The basic structure of a FLAC stream is:</p>

<ul>
  <li>the four byte string “fLaC” to identify the stream</li>
  <li>the STREAMINFO metadata block</li>
  <li>zero or more other metadata blocks</li>
  <li>one of more audio frames</li>
</ul>

<p>FLAC defines various metadata blocks. They can be used for padding, seek tables, tags, cue sheets, and even application-specific data. There is no metadata block for the ID3 tags (where the artist, album, etc info are usually stored) but the world doesn’t really care and most decoders, including the reference one, know how to handle them anyway.<br />
The only mandatory block is the STREAMINFO block. This block contains information like the sample rate, number of channels, etc., and data that can help the decoder manage its buffers, like the minimum and maximum data rate and minimum and maximum block size. Also included in the STREAMINFO block is the MD5 signature of the unencoded audio data, useful for checking an entire stream for transmission errors.</p>

<p>Following the metadata blocks there is the sequence of frames containing the compressed audio stream: FLAC first splits the un-encoded audio data into blocks and then encodes each block separately. The blocking procedure serves two purposes: it is possible to un-compress, edit and re-compress only a subset of the frames at a time and it allows for the compression parameters to change over time, which is ideal since the audio signal is most certainly not stationary (but can be approximated as such within each block). The encoded data block is then packed into a frame with a header and a footer, and is appended to the stream. There is a trade-off in choosing the block size: smaller blocks allow for better compression but require more frame headers / footers to be stored. The reference implementation defaults to a block-size of 4096 samples, which at a sampling rate of 44.1kHz equals about 93 milliseconds but in theory blocks could be of variable length.</p>

<h2 id="compressing-the-audio-signal-in-each-data-block">Compressing the audio signal in each data block</h2>
<p>The raw encoding of an audio signal is extremely space inefficient: your common 16 bit 44.1kHz raw audio signal is encoded by storing each second of audio signal as a sequence of 44100 16 bit numbers (that is 88 KB/s!) representing the quantised discrete values of the audio wave over time. Any structure in the audio signal is just be encoded as it comes: any moment of silence takes as much space as the most explosive of the cymbals!</p>

<p>At a high level, the compression procedure reduces the redundancy in the raw representation by identifying and modelling structured patterns in the raw signal: it exploits this patterns to approximate the raw signal using a mathematical function, and then also stores the approximation error so that it can revert it and recreate the original signal with no loss of information. Compression is achieved because storing both parts is much more efficient than storing the original raw signal: the approximated signal is saved by simply storing its mathematical model while the approximation error is saved more efficiently because of the use of Rice coding. Errors are almost always small and storing small numbers takes less space. In addition to this, their distribution can be assumed a priori, which allows to use a coding scheme optimised for it.</p>

<p>More specifically, the model being fitted to the signal by FLAC can either be a constant value (for silent moments), LPC or a fixed polynomial predictor from a subset of 4 that usually work well. Fixed polynomial prediction is much faster, but less accurate than LPC. The higher the maximum LPC order \(p\), the slower but more accurate the model will be. However, there are diminishing returns with increasing orders: \(p = 1\) already leads to good compression, while higher orders increase the required computation time with smaller compression benefits and in addition to this the LPC parameters take more space to save. The approximation error is then obtained by subtracting the original signal with approximated signal, and since they are (empirically) Laplace distributed they can efficiently be encoded using a simple symmetric variation of the Rice coding scheme.
These procedure is applied to both channel, left and right independently. A neat trick that can be used to often increase the compression of the block is to switch from left-right to mid-side (mid = (left + right) / 2, side = left - right).</p>

<p>According to the modelling choice, the block is then encoded. First a sub frame is built, marking the model used in the header and encoding the audio content in the sub frame body. For example, in the case of LPC the sub frame body contains the (p) initial samples, the LPC coefficient and then the sequence of the encoded residuals. Finally the frame is constructed by preceding the sub frame with a frame header ant trailing it with a frame footer. The header starts with a sync code, and contains the minimum information necessary for a decoder to play the stream, like sample rate, bits per sample, etc. It also contains the block or sample number and an 8-bit CRC of the frame header. The frame footer contains a 16-bit CRC of the entire encoded frame for error detection. If the reference decoder detects a CRC error it will generate a silent block.</p>

<h1 id="bibliography">Bibliography</h1>
<p>[1] David A Huffman. “A method for the construction of minimum-redundancycodes”. In: <em>Proceedings of the IRE</em> 40.9 (1952), pp. 1098–1101.</p>

<p>[2] Solomon Golomb. “Run-length encodings (Corresp.)” In: <em>IEEE trans-actions on information theory</em> 12.3 (1966), pp. 399–401.</p>

<p>[3] Robert Gallager and David Van Voorhis. “Optimal source codes for ge-ometrically distributed integer alphabets (corresp.)” In: <em>IEEE Trans-actions on Information theory</em> 21.2 (1975), pp. 228–230.</p>

<p>[4] Tony Robinson. SHORTEN: Simple lossless and near-lossless wave-form compression. 1994.</p>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
